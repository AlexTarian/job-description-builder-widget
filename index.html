<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Job Description Builder</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://js.jotform.com/JotFormCustomWidget.min.js"></script>
  <style>
    :root{
    --bg:#fff; --fg:#0f172a; --muted:#64748b; --line:#e2e8f0; --primary:#2563eb; --gold:#f59e0b;
    --radius:14px; --gap:10px; --control-h:42px;
    }
    *{ box-sizing: border-box; }
    body{ margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; color:var(--fg); background:var(--bg); }
    .wrap{ max-width: 860px; margin: 14px auto; padding: 16px; }
    h1{ font-size: 18px; margin: 0 0 10px; }
    .small{ font-size:12px; color:var(--muted); }
    .muted{ color:var(--muted); }
  
  
    /* Wizard container */
    .wizard{ position:relative; border:1px solid var(--line); border-radius: var(--radius); padding:16px; }
    .wiz-head{ display:flex; align-items:center; justify-content:space-between; gap:12px; }
    .wiz-title{ font-weight:700; }
    .wiz-sub{ font-size:12px; color:var(--muted); }
    .progress{ height:6px; background:#f1f5f9; border-radius:999px; overflow:hidden; margin-top:8px; }
    .progress > i{ display:block; height:100%; width:0%; background:var(--primary); }
  
    /* Category grid: max 3 columns, responsive down to 2 and 1 */
    .grid{
      display:grid;
      grid-template-columns: repeat(3, minmax(0, 1fr)); /* cap at 3 across */
      gap: var(--gap);
      margin-top:12px;
    }
    
    @media (max-width: 900px){
      .grid{ grid-template-columns: repeat(2, minmax(0, 1fr)); }
    }
    @media (max-width: 560px){
      .grid{ grid-template-columns: 1fr; }
    }
    
    .tile-cat{ border:1px solid var(--line); border-radius:0; padding:12px; cursor:pointer; background:#fff; display:flex; gap:10px; align-items:flex-start; min-height:64px; }
    .tile-cat:hover{ box-shadow: 0 2px 10px rgba(0,71,171,.2); }
    .tile-cat.selected{ outline: 2px solid var(--primary); background: #f8fbff; }
    .tile-cat .icon{ font-size:18px; line-height:1; }
    .tile-cat .icon img { width:20px; height:20px; display:block; }
    .tile-cat .txt{ display:flex; flex-direction:column; gap:4px; }
    .tile-cat .title{ font-weight:600; font-size:14px; }
    .tile-cat .sub{ font-size:12px; color:var(--muted); }
  
  
    /* Duty/summary: modern full-width list rows */
    .list{ display:flex; flex-direction:column; gap: 0; margin-top:0; max-height:360px; overflow:auto; }
    .tile{ border:none; border-radius:0; padding:12px; cursor:pointer; background:#fff; display:flex; gap:10px; align-items:center; min-height:56px; }
    .tile:hover{ background:#f8fafc; }
    .tile .accent{ width:5px; align-self:stretch; background:transparent; }
    .tile.secondary{ background:linear-gradient(to right,#f0f7ff, #ffffff); }
    .tile.secondary .accent{ background: var(--primary); }
    .tile.primary{ background:linear-gradient(to right,#fffbeb, #ffffff); }
    .tile.primary .accent{ background: var(--gold); }
    .tile .txt{ display:flex; flex-direction:column; gap:2px; flex:1; }
    .tile .title{ font-weight:600; font-size:14px; }
    .tile .sub{ font-size:12px; color:var(--muted); }
    .tile .actions { margin-left:auto; display:flex; gap:8px; }
    .btn.x { border:0 solid var(--line); background:#fff; border-radius:0; padding:6px 8px; font-size:18px; cursor:pointer; }
    .btn.x:hover { background:transparent; }
  
    
    /* star on the left with three states */
    .star{ margin-right:6px; border:0 solid var(--line); background:#fff; cursor:pointer; font-size:25px; }
    .star.gray{ color:gray; background:transparent; }
    .star.secondary{ color:gray; background:transparent; }
    .star.active{ color:var(--gold); background:transparent; }
  
    .summary-scroll { max-height: 200px; overflow-y:auto; border-top:1px solid var(--line); padding-top:8px; }
  
    /* Footer buttons */
    .row{ display:flex; gap:10px; justify-content:space-between; align-items:center; margin-top:14px; }
    .btn{ border:1px solid var(--line); background:#f8fafc; border-radius:30px; padding:10px 12px; font-size:14px; cursor:pointer; }
    .btn.primary{ background:var(--primary); color:#fff; border-color:var(--primary); }
    .btn.ghost{ background:#fff; }
    .btn:disabled{ opacity:.5; cursor:not-allowed; }
  
    textarea{ width:100%; min-height:140px; padding:10px 12px; border:1px solid var(--line); border-radius:10px; }
  </style>
  <!-- Jotform Widget API shim (dev-only; won't run inside Jotform) -->
  <script>
    if (window.self === window.top && !window.JFCustomWidget) {
      window.JFCustomWidget = {
        subscribe(ev, cb){
          if (ev === 'ready')  { document.addEventListener('DOMContentLoaded', cb); }
          if (ev === 'submit') { /* noop in local */ }
          if (ev === 'populate'){ /* noop */ }
        },
        getWidgetSettings(cb){ cb({}); },
        sendSubmit(obj){ console.log('sendSubmit (local)', obj); },
        requestFrameResize(){ /* noop */ }
      };
    }
  </script>
</head>
<body>
<div class="wrap">
  <h1>Job Description Builder 2.0</h1>
  <div id="wizard" class="wizard" role="region" aria-label="Job duties wizard">
    <div class="wiz-head">
      <div>
        <div id="wizTitle" class="wiz-title">Step 1: Choose applicable categories</div>
        <div id="wizSub" class="wiz-sub">Select all the categories related to the tasks workers will perform.</div>
      </div>
      <div id="stepBadge" class="small">Step <span id="stepNum">1</span>/<span id="stepTotal">3</span></div>
    </div>
    <div class="progress"><i id="progressBar" style="width:0%"></i></div>

    <div id="stage"></div>

    <div class="row">
      <div>
        <button id="backBtn" class="btn ghost" type="button">Back</button>
      </div>
      <div style="display:flex; gap:10px">
        <button id="nextBtn" class="btn primary" type="button">Next</button>
      </div>
    </div>
  </div>

  <div class="section" style="margin-top:12px;">
    <label for="preview" class="small">Job description preview</label>
    <textarea id="preview" readonly></textarea>
    <div class="section small" id="status"></div>
    <button id="editWizardBtn" class="btn ghost" type="button" style="margin-top:8px; display:none;">
      Edit with wizard
    </button>
  </div>
</div>
<script>
  // --- JF lifecycle harness (2025 style) ----------------------------
  let JF = null;                  // holds the real API after 'ready'
  let pendingValue = null;        // last value we wanted to send before JF existed
  
  function setPending(v){ pendingValue = v; }
  function flushIfReady(){
    if (!JF || pendingValue == null) return;
    try { JF.sendSubmit({ valid: true, value: pendingValue }); }
    catch(e){ /* swallow + keep pending so we can retry */ return; }
    pendingValue = null;
  }

  
  // --- Lightweight logger that prints to console and to the #status element ---
const Debug = (() => {
  let sink = null;              // element to print into (we'll attach later)
  const buf = [];               // buffer until attached
  const MAX = 120;              // keep last N lines in the UI

  function toStr(x) {
    try {
      if (x === undefined) return 'undefined';
      if (x === null) return 'null';
      if (typeof x === 'string') return x;
      return JSON.stringify(x);
    } catch { return String(x); }
  }

  function line(...args) {
    const ts = new Date().toLocaleTimeString();
    return `[${ts}] ${args.map(toStr).join(' ')}`;
  }

  function log(...args) {
    console.log('[WIDGET]', ...args);
    const l = line(...args);
    if (sink) {
      const arr = (sink.textContent ? sink.textContent.split('\n') : []).concat(l);
      sink.textContent = arr.slice(-MAX).join('\n');
    } else {
      buf.push(l);
      if (buf.length > MAX * 2) buf.shift();
    }
  }

  function attach(el) {
    sink = el || null;
    if (sink && buf.length) {
      sink.textContent = buf.slice(-MAX).join('\n');
    }
  }

  return { log, attach };
})();

// Global error taps (great for â€œwhy is submit hanging?â€ moments)
window.addEventListener('error', (e) => {
  Debug.log('window.onerror:', e.message, e.filename, e.lineno + ':' + e.colno);
});
window.addEventListener('unhandledrejection', (e) => {
  Debug.log('unhandledrejection:', toString(e.reason || e));
  function toString(r){ try { return typeof r === 'string' ? r : JSON.stringify(r); } catch { return String(r); } }
});

  (function(){
    // ===== State =====
    const state = {
      flow: 'categories', // 'categories' | 'duties' | 'summary'
      categories: [
        { key:'farmwork', label:'General Farming', icon:'ðŸŒ¾' },
        { key:'equipment', label:'Equipment Operation', icon:'ðŸšœ' },
        { key:'livestock', label:'Livestock Work', icon:'ðŸ„' },
        { key:'maintenance', label:'Repair & Maintenance', icon:'ðŸ› ï¸' },
        { key:'trucking', label:'Trucking', icon:'ðŸšš' },
        { key:'chemical', label:'Chemical Application', icon:'ðŸ§ª' },
        { key:'construction', label:'Construction', icon:'ðŸ‘·' },
        { key:'supervision', label:'Supervision', icon:'ðŸ§‘â€ðŸ’¼' },
        { key:'beekeeping', label:'Beekeeping', icon:'ðŸ' },
        { key:'crop dusting', label:'Crop Dusting', icon:'âœˆï¸' },
      ],
      selectedCategories: new Set(),
      categoryOrder: [],
      currentIndex: 0,
      lastKey: null,
      dutiesByCategory: new Map(),
      selections: new Map(),
    };
    
    state.prevCategoryKey = null;
    state.lastSummary = { section: null, key: null };
  
    // ===== DOM =====
    const el = {
      stage: document.getElementById('stage'),
      preview: document.getElementById('preview'),
      backBtn: document.getElementById('backBtn'),
      nextBtn: document.getElementById('nextBtn'),
      wizTitle: document.getElementById('wizTitle'),
      wizSub: document.getElementById('wizSub'),
      stepNum: document.getElementById('stepNum'),
      stepTotal: document.getElementById('stepTotal'),
      progressBar: document.getElementById('progressBar'),
      status: document.getElementById('status'),
      editWizardBtn: document.getElementById('editWizardBtn'),
    };

    // hook the UI log sink
    Debug.attach(el.status);
    Debug.log('boot: DOM wired');

    el.preview.addEventListener('input', () => {
      if (state.flow === 'done') autosend();
    });

    if (el.editWizardBtn) {
      el.editWizardBtn.addEventListener('click', exitDoneMode);
    }
  
    const setStatus = (t)=> el.status.textContent = t || '';
    function debounce(fn, wait=300, maxWaitMs=null){
      let t=null, start=null;
      const run = (...a) => { t && clearTimeout(t); t=null; start=null; fn(...a); };
      const d = (...a) => {
        const now = Date.now();
        if (start==null) start = now;
        if (maxWaitMs!=null && now - start >= maxWaitMs) return run(...a);
        t && clearTimeout(t);
        t = setTimeout(() => run(...a), wait);
      };
      d.flush = (...a) => run(...a);
      d.cancel = () => { t && clearTimeout(t); t=null; start=null; };
      return d;
    }

    // --- Icon base and helper ---
    const ICON_BASE = 'https://AlexTarian.github.io/job-description-builder-widget/assets/icons/';

    
    function iconUrlFor(catKey){
      return ICON_BASE.replace(/\/+$/,'/') + encodeURIComponent(catKey) + '.svg';
    }
    
    // ===== Utilities =====
    const keyFrom = (it)=> `${it.duty}${it.title||''}`;
    function ensureCatMap(cat){ if(!state.selections.has(cat)) state.selections.set(cat, new Map()); return state.selections.get(cat); }
  
    function toggleDuty(cat, it){
      const m = ensureCatMap(cat); const k = keyFrom(it);
      if(m.has(k)) m.delete(k); else m.set(k, { ...it, primary:false });
      syncOutput();
    }
    function togglePrimary(cat, it){
      const m = ensureCatMap(cat); const k = keyFrom(it);
      if(!m.has(k)){ m.set(k, { ...it, primary:true }); }
      else { const cur = m.get(k); cur.primary = !cur.primary; m.set(k, cur); }
      syncOutput();
    }
  
    function currentCatKey(){ return state.categoryOrder[state.currentIndex] || null; }
    function countSelected(){ let n=0, prim=0; for(const m of state.selections.values()){ for(const v of m.values()){ n++; if(v.primary) prim++; } } return { n, prim }; }
  
    function buildParagraph(){
      const all = [];
      for(const [, m] of state.selections.entries()){
        for(const v of m.values()) all.push(v.duty);
      }
      const txt = all.map(s=>s.trim()).filter(Boolean).join('; ');
      if(!txt) return '';
      return /[.!?]$/.test(txt) ? txt : txt + '.';
    }
  
    function buildPreviewSections() {
      const primary = [];
      const secondary = [];
      for (const [, m] of state.selections.entries()) {
        for (const v of m.values()) (v.primary ? primary : secondary).push(v.duty);
      }
      return { primary, secondary };
    }
  
    function renderPreviewText() {
      const { primary, secondary } = buildPreviewSections();
      const primText = primary.length ? `Primary duties include: ${primary.join('; ')}.` : '';
      const secText  = secondary.length ? `\nAdditional duties may include: ${secondary.join('; ')}.` : '';
      return [primText, secText].filter(Boolean).join(''); // <- no extra space before newline
    }

    function enterDoneMode() {
      Debug.log('enterDoneMode()');
      document.getElementById('wizard').style.display = 'none';
    
      // Make preview editable + fill with split text
      el.preview.removeAttribute('readonly');
      el.preview.value = renderPreviewText();
      el.preview.focus();
      el.preview.setSelectionRange(el.preview.value.length, el.preview.value.length);
    
      // Show the â€œEdit with wizardâ€ button
      if (el.editWizardBtn) el.editWizardBtn.style.display = '';
    
      state.flow = 'done';
      autosend.flush();
      setStatus('You can edit the text directly. Changes will be saved automatically.');
      try { JF && JF.requestFrameResize({ height: document.documentElement.scrollHeight }); } catch {}
    }
    
    function exitDoneMode() {
      // Show wizard again at the summary step (so they can tweak primaries, etc.)
      document.getElementById('wizard').style.display = '';
      el.preview.setAttribute('readonly', 'readonly');

      if (el.editWizardBtn) el.editWizardBtn.style.display = 'none';
    
      state.flow = 'summary';
      renderSummary();
      setStatus('');
      try { JF && JF.requestFrameResize({ height: document.documentElement.scrollHeight }); } catch {}
    }
  
    function buildPayload(){
      const out = { primary:[], other:[], selected:[], description:'' };
      for (const [cat, m] of state.selections.entries()){
        for (const v of m.values()){
          const rec = { duty:v.duty, title:v.title||'Unclassified', category:cat, primary: !!v.primary };
          out.selected.push(rec);
          if (v.primary) out.primary.push(v.duty); else out.other.push(v.duty);
        }
      }
      out.description = (state.flow === 'done')
        ? String(el.preview.value || '').trim()
        : renderPreviewText();
      Debug.log('buildPayload snapshot:', {
        primaryCount: out.primary.length,
        otherCount: out.other.length,
        selectedCount: out.selected.length,
        descLen: out.description.length
      });
      return out;
    }

    // Called by autosave or on submit
    function sendNow(){
      try {
        const value = JSON.stringify(buildPayload());
        if (!JF) { setPending(value); return; }
        JF.sendSubmit({ valid: true, value });
      } catch(_) {}
    }

    const autosend = debounce(() => {
      setPending(JSON.stringify(buildPayload()));
      flushIfReady(); // will no-op until JF is set in 'ready'
    }, 400, 2000);

    const syncOutput = () => { el.preview.value = renderPreviewText(); autosend(); };
  
    function resize(){ try { JF && JF.requestFrameResize({ height: document.documentElement.scrollHeight }); } catch {} }
  
    // ===== Rendering =====
    function setStepMeta(){
      // while on categories, count the live selection; otherwise use the locked-in order
      const chosenCount = (state.flow === 'categories')
        ? state.selectedCategories.size
        : state.categoryOrder.length;
    
      const totalSteps = 2 + chosenCount; // categories + each chosen category + summary
    
      let curStep = 1; // categories = step 1
      if (state.flow === 'duties')   curStep = 1 + (state.currentIndex + 1);
      if (state.flow === 'summary')  curStep = 1 + chosenCount + 1;
    
      el.stepNum.textContent   = String(curStep);
      el.stepTotal.textContent = String(totalSteps);
    
      const pct = (totalSteps > 1)
        ? Math.round(((curStep - 1) / (totalSteps - 1)) * 100)
        : 0;
    
      el.progressBar.style.width = pct + '%';
    }
  
    function renderCategories(){
      state.flow = 'categories';
      el.wizTitle.textContent = 'Step 1: Choose applicable categories';
      el.wizSub.textContent = 'Select one or more categories to include.';
      el.backBtn.disabled = true;
      el.nextBtn.textContent = 'Next';
      el.nextBtn.disabled = false;
  
      const grid = document.createElement('div'); grid.className='grid';
      state.categories.forEach(cat=>{
        const selected = state.selectedCategories.has(cat.key);
        const tile = document.createElement('div'); tile.className='tile-cat'; if(selected) tile.classList.add('selected'); tile.tabIndex=0;
        const sub = selected ? 'Selected' : 'Tap to select';
        tile.innerHTML = `
          <div class="icon">
            <img alt="" loading="lazy" decoding="async"
             src="${cat.iconUrl || iconUrlFor(cat.key)}"
             onerror="this.outerHTML='<span>${(cat.icon || 'â€¢').replace(/'/g, '\\\'')}</span>'">
          </div>
          <div class="txt">
            <div class="title">${cat.label}</div>
            <div class="sub">${sub}</div>
          </div>`;
        const toggle=()=>{ if(selected){ state.selectedCategories.delete(cat.key);} else { state.selectedCategories.add(cat.key);} renderCategories(); };
        tile.onclick = toggle; tile.onkeydown = (e)=>{ if(e.key==='Enter' || e.key===' '){ e.preventDefault(); toggle(); } };
        grid.appendChild(tile);
      });
      el.stage.innerHTML=''; el.stage.appendChild(grid);
  
      el.nextBtn.onclick = ()=>{
        state.categoryOrder = Array.from(state.selectedCategories);
        if(state.categoryOrder.length===0){ setStatus('Please select at least one category (you can change later).'); return; }
        state.currentIndex = 0; renderDuties(); setStatus('');
      };
      setStepMeta(); resize();
    }

    // Update one tileâ€™s visuals without rebuilding the whole list
    function setTileState(tile, selectedRec){
      // classes
      tile.classList.toggle('primary',  !!(selectedRec && selectedRec.primary));
      tile.classList.toggle('secondary',!!(selectedRec && !selectedRec.primary));
      if (!selectedRec) {
        tile.classList.remove('primary','secondary');
      }
    
      // star + subtext
      const star = tile.querySelector('.star');
      const sub  = tile.querySelector('.sub');
    
      if (selectedRec) {
        const isPrimary = !!selectedRec.primary;
        star.className = 'star ' + (isPrimary ? 'active' : 'secondary');
        star.setAttribute('aria-pressed', String(isPrimary));
        if (sub) sub.textContent = isPrimary ? 'Primary' : 'Secondary';
        else tile.querySelector('.txt')
          .insertAdjacentHTML('beforeend', `<div class="sub">${isPrimary ? 'Primary' : 'Secondary'}</div>`);
      } else {
        star.className = 'star gray';
        star.setAttribute('aria-pressed', 'false');
        if (sub) sub.textContent = 'Tap to Select';
      }
    }
  
    function renderDuties(){
      state.flow = 'duties';
      const cat = currentCatKey();
      const isNewCategory = state.prevCategoryKey !== cat;
      const catMeta = state.categories.find(c=>c.key===cat);
      const items = (state.dutiesByCategory.get(cat) || []).slice();
    
      // read old scroll only if staying on same category
      const oldList = el.stage.querySelector('.list');
      const prevScroll = (!isNewCategory && oldList) ? oldList.scrollTop : 0;
    
      el.wizTitle.textContent = `Select duties: ${catMeta?.label||cat}`;
      el.wizSub.textContent = 'Tap tiles to select/deselect applicable job duties. Tap â˜… to mark duties as primary tasks.';
      el.backBtn.disabled = false;
      el.nextBtn.textContent = 'Next';
      el.nextBtn.disabled = false;
    
      // Build index for fast lookups from data-key â†’ { duty, title }
      const itemsByKey = new Map(items.map(it => [keyFrom(it), it]));
      const selMap = ensureCatMap(cat);
    
      // (Re)build list only when switching categories (or first time)
      const list = document.createElement('div');
      list.className='list';
    
      items.forEach(it=>{
        const k = keyFrom(it);
        const selected = selMap.get(k); // undefined or {duty,title,primary}
        const tile = document.createElement('div');
        tile.className = 'tile';
        tile.tabIndex = 0;
        tile.dataset.key = k;
    
        // initial markup (no conditional classes yet)
        tile.innerHTML = `
          <i class="accent"></i>
          <button class="star gray" type="button" aria-pressed="false">â˜…</button>
          <div class="txt">
            <div class="title">${it.duty}</div>
            <div class="sub">Tap to Select</div>
          </div>
        `;
    
        // now set visual state based on current selection
        setTileState(tile, selected);
    
        list.appendChild(tile);
      });
    
      // Replace stage content
      el.stage.innerHTML = '';
      el.stage.appendChild(list);
    
      // Single delegated handler for the entire list
      list.addEventListener('click', (e) => {
        const tile = e.target.closest('.tile');
        if (!tile) return;
        const k = tile.dataset.key;
        const it = itemsByKey.get(k);
        if (!it) return;
    
        const clickedStar = e.target.closest('button.star');
    
        if (clickedStar) {
          // Toggle primary (auto-select if not selected)
          togglePrimary(cat, it);
        } else {
          // Toggle selection
          toggleDuty(cat, it);
        }
    
        // Reflect new state on THIS tile only
        const rec = ensureCatMap(cat).get(k);
        setTileState(tile, rec);
        state.lastKey = k;           // optional: for focus persistence
      });
    
      // Keyboard toggle (delegated)
      list.addEventListener('keydown', (e) => {
        if (e.key !== 'Enter' && e.key !== ' ') return;
        const tile = e.target.closest('.tile');
        if (!tile) return;
        e.preventDefault();
        const k = tile.dataset.key;
        const it = itemsByKey.get(k);
        if (!it) return;
        toggleDuty(cat, it);
        const rec = ensureCatMap(cat).get(k);
        setTileState(tile, rec);
        state.lastKey = k;
      });
    
      // restore or reset scroll/focus
      requestAnimationFrame(() => {
        list.scrollTop = prevScroll;                 // 0 for new category, previous for same
        if (isNewCategory) state.lastKey = null;     // don't try to refocus old item on new category
        if (state.lastKey) {
          const node = list.querySelector(`[data-key="${CSS.escape(state.lastKey)}"]`);
          if (node) node.focus({ preventScroll: true });
        }
      });
    
      el.backBtn.onclick = ()=>{
        if(state.currentIndex===0){ renderCategories(); }
        else { state.currentIndex--; renderDuties(); }
      };
      el.nextBtn.onclick = ()=>{
        state.currentIndex++;
        if(state.currentIndex >= state.categoryOrder.length){ renderSummary(); }
        else { renderDuties(); }
      };
    
      setStepMeta();
      resize();
    
      // remember category rendered
      state.prevCategoryKey = cat;
    }
  
    function renderSummary(){
      Debug.log('renderSummary(): totals =', countSelected());
      state.flow = 'summary';
      el.wizTitle.textContent = 'Review selected duties';
      const counts = countSelected();
      el.wizSub.innerHTML = `Primary duties: <b>${counts.prim}</b> â€¢ Total selected: <b>${counts.n}</b>`;
      el.backBtn.disabled = false;
      el.nextBtn.textContent = 'Confirm & Save';
      el.nextBtn.disabled = false;
    
      // 1) Read pre-render scroll positions (if present)
      const oldPrimaryList = el.stage.querySelector('#sum-primary');
      const oldOtherList   = el.stage.querySelector('#sum-other');
      const prevScroll = {
        primary: oldPrimaryList ? oldPrimaryList.scrollTop : 0,
        other:   oldOtherList   ? oldOtherList.scrollTop   : 0
      };
    
      const primary=[], other=[];
      for (const [cat, m] of state.selections.entries()){
        for (const v of m.values()){ (v.primary?primary:other).push({ ...v, cat }); }
      }
    
      const wrap = document.createElement('div');
    
      const section = (title, arr, sectionKey)=>{
        const box = document.createElement('div');
        const h = document.createElement('div');
        h.className='row';
        h.innerHTML = `<div class="small"><b>${title}</b></div>`;
        box.appendChild(h);
    
        const list = document.createElement('div');
        list.className='list summary-scroll';
        list.id = sectionKey === 'primary' ? 'sum-primary' : 'sum-other';
    
        arr.forEach(it=>{
          const k = keyFrom(it); // `${duty}\u0001${title}`
          const tile = document.createElement('div');
          tile.className = 'tile ' + (it.primary?'primary':'secondary');
          tile.dataset.key = k;
          const starCls = it.primary ? 'star active' : 'star secondary';
          const subTxt = it.primary ? 'Primary' : 'Secondary';
          tile.innerHTML = `
            <i class="accent"></i>
            <button class="${starCls}" type="button" aria-pressed="${it.primary}">â˜…</button>
            <div class="txt">
              <div class="title">${it.duty}</div>
              <div class="sub">${subTxt}</div>
            </div>
            <div class="actions">
              <button class="btn x" type="button" aria-label="Remove duty">Ã—</button>
            </div>
          `;
    
          // star toggle
          tile.querySelector('.star').onclick = (e)=>{
            e.stopPropagation();
            state.lastSummary = { section: sectionKey, key: k };   // remember
            togglePrimary(it.cat, it);
            renderSummary();
          };
    
          // remove with confirm
          tile.querySelector('.btn.x').onclick = (e)=>{
            e.stopPropagation();
            if (confirm('Remove this duty from the job?')) {
              const m = ensureCatMap(it.cat);
              m.delete(k);
              state.lastSummary = { section: sectionKey, key: null }; // no specific focus target
              syncOutput();
              renderSummary();
            }
          };
    
          list.appendChild(tile);
        });
    
        box.appendChild(list);
        return box;
      };
    
      if(primary.length){ wrap.appendChild(section('Primary duties', primary, 'primary')); }
      if(other.length){ wrap.appendChild(section('Other selected duties', other, 'other')); }
    
      el.stage.innerHTML=''; 
      el.stage.appendChild(wrap);
    
      el.backBtn.onclick = ()=>{ 
        if(state.categoryOrder.length>0){ state.currentIndex = state.categoryOrder.length-1; renderDuties(); } 
        else { renderCategories(); } 
      };
      el.nextBtn.onclick = ()=> { enterDoneMode(); };
    
      setStepMeta(); 
      resize();
    
      // 3) Restore scroll + focus
      requestAnimationFrame(()=>{
        const newPrimary = el.stage.querySelector('#sum-primary');
        const newOther   = el.stage.querySelector('#sum-other');
        if (newPrimary) newPrimary.scrollTop = prevScroll.primary;
        if (newOther)   newOther.scrollTop   = prevScroll.other;
    
        if (state.lastSummary.section && state.lastSummary.key){
          const listId = state.lastSummary.section === 'primary' ? '#sum-primary' : '#sum-other';
          const target = el.stage.querySelector(`${listId} [data-key="${CSS.escape(state.lastSummary.key)}"]`);
          if (target) target.focus({ preventScroll: true });
        }
      });
    }
  
    function groupByCategory(list){
      const byCat = new Map();
      for (const row of list){
        const cat = String(row.category || 'farmwork');
        const duty = String(row.duty || '').trim();
        const title = String(row.title || 'Unclassified').trim();
        if (!duty) continue;
        if (!byCat.has(cat)) byCat.set(cat, []);
        byCat.get(cat).push({ duty, title });
      }
      return byCat;
    }
    
    async function fetchJson(url){
      const res = await fetch(url, { cache: 'no-store' });
      if (!res.ok) throw new Error(`HTTP ${res.status} for ${url}`);
      return res.json();
    }
    
    async function init(){
      Debug.log('init() start');
      Debug.log('env:', window.self === window.top ? 'local-dev (shim)' : 'jotform-iframe (real API)');
      const relUrl = new URL('./assets/duties/duties.json', location.href).href;
      const absUrl = 'https://AlexTarian.github.io/job-description-builder-widget/assets/duties/duties.json';
    
      async function load(url){
        const data = await fetchJson(url);
        // Support both shapes:
        if (Array.isArray(data)) {
          return groupByCategory(data); // [{duty,title,category}, ...]
        } else {
          // { categoryKey: [{duty,title}, ...] }
          const byCat = new Map();
          for (const [k, arr] of Object.entries(data)){
            byCat.set(
              k,
              (Array.isArray(arr) ? arr : []).map(r => ({
                duty: String(r.duty || '').trim(),
                title: String(r.title || 'Unclassified').trim()
              })).filter(r => r.duty)
            );
          }
          return byCat;
        }
      }
    
      try {
        state.dutiesByCategory = await load(relUrl);
      } catch (e1){
        console.warn('Relative duties load failed, trying GitHub...', e1);
        try {
          state.dutiesByCategory = await load(absUrl);
        } catch (e2){
          console.error('duties.json load failed', e1, e2);
          setStatus('âš ï¸ Could not load duties list. Please check the file path and format.');
          // Still render categories UI so the page isnâ€™t blank
          renderCategories();
          return;
        }
      }
    
      // Success path
      renderCategories();
      el.preview.value = renderPreviewText();
      setStatus('');
    }

    // === All JF wiring in one place (Item 3) ===
    JFCustomWidget.subscribe('ready', () => {
      // Bind the real API locally so we never hit the global again
      // (Assumes you set `let JF = null;` in Item 1)
      JF = JFCustomWidget;
      Debug.log('JF ready');
    
      // Wire SUBMIT: send the freshest payload immediately (no debounce)
      JF.subscribe('submit', () => {
        Debug.log('JF submit â†’ sendNow');
        try { 
          // If you kept autosave debounce, flush it first so we don't lose keystrokes
          if (typeof autosend?.flush === 'function') autosend.flush();
          sendNow(); 
        } catch (e) { Debug.log('sendNow error on submit', e?.message || e); }
      });
    
      // Wire POPULATE: accept either a JSON string or object
      JF.subscribe('populate', (msg) => {
        const raw = msg && msg.value;
        try {
          const data = (raw && typeof raw === 'string') ? JSON.parse(raw) : raw;
          if (!data || !Array.isArray(data.selected)) return;
    
          state.selections.clear();
          data.selected.forEach(r => {
            const cat = r.category || 'general';
            const m = ensureCatMap(cat);
            const k = `${r.duty}\u0001${r.title || ''}`;
            m.set(k, { duty: r.duty, title: r.title, primary: !!r.primary });
          });
    
          renderSummary(); // your existing summary renderer
        } catch (err) {
          console.warn('populate parse issue', err);
        }
      });
    
      // Initialize the UI/data now that we are in a real JF widget frame
      try { init(); } catch (e) { Debug.log('init error', e?.message || e); }
    
      // Size the frame once on load (optional, safe-guarded)
      try { JF.requestFrameResize({ height: document.documentElement.scrollHeight }); } catch {}
    
      // If you implemented Item 1's pending-send mechanism, flush it now
      if (typeof flushIfReady === 'function') flushIfReady();
    });


    document.addEventListener('DOMContentLoaded', () => {
    const stageEmpty = !document.getElementById('stage')?.firstChild;
    if (stageEmpty) {
      Debug.log('fallback init on DOMContentLoaded');
      try { init(); } catch (e) { Debug.log('fallback init error', e?.message || e); }
    }
  });

  })();
  </script>
</body>
</html>
